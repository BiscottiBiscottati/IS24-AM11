@startuml ProjectIngSoftModel

skinparam BackgroundColor ghostwhite

package cards.playable{


    abstract class PlayableCard{
      # PlayableCard(PlayableCardBuilder):
      - id: int
      - color: Color
      - points: int
      + getId(): int
      + getPoints(): int
      + getColor(): Color
      + getCenter(isRetro: boolean): Set<Color>
      + countPoints(PlayerField, Position): int
      + {abstract} getType(): PlayableCardType
      + {abstract} isFrontAvailable(Corner): boolean
      + {abstract} getPlacingRequirements(): Map<Color, Integer>
      + {abstract} getPlacingRequirementsOf(Color): int
      + {abstract} getPointsRequirements(): PointsRequirementsType
      + {abstract} getItemCorner(Corner): CornerContainer
      + {abstract} getSymbolToCollect(): Optional<Symbol>
    }

    class GoldCard extends PlayableCard{
      - colorPlacingRequirements: Map<Color, Integer>
      - availableCornersOrSymbol: Map<Corner, CornerContainer>
      - pointsRequirements: PointsRequirementsType
      - symbolToCollect: Symbol
      - GoldCard(GoldCardBuilder)
    }

    class ResourceCard extends PlayableCard{
      - availableCornerOrItem: Map<Corner, CornerContainer>
      - ResourceCard(ResourceCardBuilder)
    }

    abstract class Builder <T extends PlayableCard>{
      - id: int
      - cardPoints: int
      - primaryColor: Color

      # Builder(id, cardPoints, Color)
      + {abstract} hasIn(Corner, CornerContainer): Builder<T>
      + {abstract} build(): Builder<T>
    }

    class GoldCardBuilder extends Builder <GoldCard>{
      - availableCornersOrSymbol: EnumMap<Corner, CornerContainer>
      - colorPlacingRequirements: EnumMap<Color, Integer>
      - pointsRequirements: PointsRequirementsType
      - symbolToCollect: Symbol

      + GoldCardBuilder(id, points, Color)
      + hasCorner(Corner, isAvailable: boolean): GoldCardBuilder
      + hasCorner(Corner): GoldCardBuilder
      + hasRequirements(Color, int): GoldCardBuilder
      + hasPointsRequirements(PointsRequirementsType): GoldCardBuilder
      + hasSymbolToCollect(Symbol): GoldCardBuilder
    }


    class ResourceCardBuilder extends Builder <ResourceCard>{
      - availableCornerOrItem: EnumMap<Corne, CornerContainer>

      + ResourceCardBuilder(id, points, Color)
    }

    PlayableCard +-- Builder
    GoldCard +-- GoldCardBuilder
    ResourceCard +-- ResourceCardBuilder
}
package cards.starter{
    class StarterCard{
      - id: int
      - availableCornersFront: Map<Corner, Availability>
      - availableColorCornerRetro: Map<Corner, Color>
      - centerColorsFront: Set<Color>

      - StarterCard(StarterCardBuilder)
      + getId(): int
      + getRetroColorIn(Corner): Color
      + isFrontCornerAvail(Corner): boolean
      + getCenterColorsFront(): Set<Color>
    }

  class StarterCardBuilder {
    - availableCornersFront: EnumMap<Corner, Availability>
    - availableColorCornerBack: EnumMap<Corner, Color>
    - centerColors: EnumSet<Color>

    + hasAvailableFrontCorner(Corner): StarterCardBuilder
    + hasColorBackIn(Corner, Color): StarterCardBuilder
    + hasCenterColors(Set<Color>): StarterCardBuilder
    + hasCenterColors(Color): StarterCardBuilder
    + build(): StarterCard
  }

  StarterCard +-- StarterCardBuilder
}

package cards.utils{
    interface CardIdentity <<sealed>> {
      + getId(): int
    }

    interface FieldCard <<sealed>> implements CardIdentity {
      + isColorEqual(Color): boolean
      + isAvailable(Corner, isRetro: boolean): boolean
      + getItemCorner(Corner, isRetro: boolean): CornerContainer
      + getCenter(isRetro: boolean): Set<Color>
    }

}

FieldCard <|.. PlayableCard
FieldCard <|.. StarterCard

package cards.utils{
    interface DatabaseSearchable {
        + getColumnName(): String
    }

    interface CornerContainer << sealed >> {
      + isAvailable(): boolean
      + getItem(): Optional<Item>
      + getTUICode(): String
    }

    interface Item << sealed >> implements DatabaseSearchable{
    }
    
    package enums{
        enum Corner{
          + DOWN_RX
          + TOP_RX
          + DOWN_LX
          + TOP_LX
        }

        enum Availability{
          + USABLE
          + NOT_USABLE
        }

        enum Color{
          + RED
          + PURPLE
          + BLUE
          + GREEN
        }

        enum Symbol{
          + PAPER
          + GLASS
          + FEATHER
        }
        enum ObjectiveCardType  {
          + L_SHAPE
          + TRIPLET
          + OBJECT_COLLECT
          + COLOR_COLLECT

          + getPositions(isFlipped: boolean, isRotated: boolean): Optional<Set<Position>>
        }

        enum PlayableCardType  {
          + GOLD
          + RESOURCE

          + getName(): String
        }

        enum PointsRequirementsType  {
          + CLASSIC
          + COVERING_CORNERS
          + SYMBOLS
        }

        enum PatternPurpose {
            + ADJACENT_LX
            + ADJACENT_RX
            + NEXT_CHECK
            + PREVIOUS_CHECK
            + TO_COMPLETE
        }
    }

    DatabaseSearchable <|.. Corner
    CornerContainer <|.. Availability
    CornerContainer <|.. Color
    CornerContainer <|.. Symbol
    Item <|.. Color
    Item <|.. Symbol

}

package cards.objective{
    abstract class ObjectiveCard {
      - id: int
      - points: int

      # ObjectiveCard(ObjectiveBuilder):
      + getPoints(): int
      + hasItemRequirements(Item): int
      + {abstract} getColorRequirements(): Map<Color, Integer>
      + {abstract} getSymbolRequirements(): Map<Symbol, Integer>
      + {abstract} getType(): ObjectiveCardType
      + {abstract} countPoints(PlayerField): int
    }

    abstract class CollectingCard extends ObjectiveCard{
      # CollectingCard(CollectingBuilder):
    }
    abstract class PositioningCard extends ObjectiveCard{
      - colorsOfPattern: Map<Color, Integer>
      # PositioningCard(PositioningBuilder)
      + {abstract} getPattern(): List<List<Color>>
    }

    abstract class ObjectiveBuilder <T extends ObjectiveCard> {
        - id: int
        - points: int

        # ObjectiveBuilder(id, int)

        + {abstract} build(): <T>
    }

    abstract class CollectingBuilder <T extends CollectingCard> extends ObjectiveBuilder{
        # CollectingBuilder(id, points)
    }

    abstract class PositioningBuilder <T extends PositioningCard> extends ObjectiveBuilder{
        # PositioningBuilder(id, points)
    }

    package collecting {
        class ColorCollectCard{
          - colorToCollect: Map<Color, Integer>
          - ColorCollectCard(ColorCollectBuilder)
        }
        class SymbolCollectCard{
          - SymbolCollectCard(SymbolCollectBuilder)
          - symbolToCollect: Map<Symbol, Integer>
        }

        class ColorCollectBuilder{
            - colorToCollect: EnumMap<Color, Integer>

            + ColorCollectBuilder(id, points)
            + hasColor(Color, int): ColorCollectBuilder
            + hasColor(Color): ColorCollectBuilder
        }

        class SymbolCollectBuilder{
            - symbolToCollect: EnumMap<Symbol, Integer>

            + SymbolCollectBuilder(id, points)
            + hasSymbol(Symbol, int): SymbolCollectBuilder
            + hasSymbol(Symbol): SymbolCollectBuilder
        }
    }

    CollectingCard <|-- ColorCollectCard
    CollectingCard <|-- SymbolCollectCard
    CollectingBuilder <|-- ColorCollectBuilder
    CollectingBuilder <|-- SymbolCollectBuilder

    package positioning{
        class TripletCard{
          - flippedFlag: boolean
          - colorOfPattern: Color
          - counter: PatternCounter
          - pattern: List<List<Color>>

          - TripletCard(TripletBuilder)
          + isFlipped(): boolean
        }

        class LCard{
          - isFlippedFlag: boolean
          - isRotatedFlag: boolean
          - primaryColor: Color
          - secondaryColor: Color
          - pattern: List<List<Color>>

          - LCard(LBuilder)
          + isFlipped(): boolean
          + isRotated(): boolean
        }

        class TripletBuilder{
            - colorRequirements: EnumMap<Color, Integer>
            - flippedFlag: boolean
            - colorOfPattern: Color

            + isFlipped(boolean): TripletBuilder
            + hasColor(Color): TripletBuilder
        }

        class LBuilder{
            - flippedFlag: boolean
            - rotatedFlag: boolean
            - primaryColor: Color
            - secondaryColor: Color
            - colorRequirements: EnumMap<Color, Integer>
            - counter: PatternCounter

            + isFlipped(boolean): LBuilder
            + isRotated(boolean): LBuilder
            + hasPrimaryColor(Color): LBuilder
            + hasSecondaryColor(Color): LBuilder
        }

        interface PatternCounter{
            + count(PlayerField): int
        }

        class LPatternCounter implements PatternCounter{
        }

        class TripletPatternCounter implements PatternCounter{
        }
    }

    PositioningCard <|-- TripletCard
    PositioningCard <|-- LCard
    PositioningBuilder <|-- TripletBuilder
    PositioningBuilder <|-- LBuilder





    ObjectiveCard +-- ObjectiveBuilder
    CollectingCard +-- CollectingBuilder
    PositioningCard +-- PositioningBuilder
    ColorCollectCard +-- ColorCollectBuilder
    SymbolCollectCard +-- SymbolCollectBuilder
    TripletCard +-- TripletBuilder
    LCard +-- LBuilder

}

CardIdentity <|.. ObjectiveCard

package decks{
    package utils {

        class CardDecoder{
            - {static}objectiveDeck: Deck<ObjectiveCard>
            - {static}starterDeck: Deck<StarterCard>
            - {static}goldDeck: Deck<GoldCard>
            - {static}resourceDeck: Deck<ResourceCard>

            + {static}decodeObjectiveCard(int): Optional<ObjectiveCard>
            + {static}decodeFieldCard(int): Optional<FieldCard>
            + {static}decodePlayableCard(int): Optional<PlayableCard>
            + {static}decodeResourceCard(int): Optional<ResourceCard>
            + {static}decodeGoldCard(int): Optional<GoldCard>
            + {static}decodeStarterCard(int): Optional<StarterCard>
        }

        class DatabaseConstants{
            + {static}DATABASE_URL
        }
    }

    class Deck <T extends CardIdentity>{
        - mappingIdToCard: Map<Integer, T>
        - deck: ArrayDeque<T>

        + Deck(mappingIdToCard: Map<Integer, T>)

        + shuffle(): Deck<T>
        + draw(): Optional<T>
        + getRemainingCards(): int
        + getDeckType(): DeckType
        + reset(): void
        + getCardByID(int): T
        + peekTop(): Optional<T>
        + save(): DeckMemento
        + load(DeckMemento): void
    }

    package objective{
        class ObjectiveDeckFactory {
            + {static} createDeck(): Deck<ObjectiveCard>
        }
    }

    package playable{
        class GoldDeckFactory {
            + {static} createDeck(): Deck<GoldCard>
        }

        class ResourceDeckFactory {
            + {static} createDeck(): Deck<ResourceCard>
        }
    }

    package starter {
        class StarterDeckFactory {
            + {static} createDeck(): Deck<StarterCard>
        }
    }
}

package players{
    class Player {
        -nickname: String
        -color: PlayerColor
        -space: PersonalSpace
        -field: PlayerField

        +getNickname(): String
        +getColor(): Color
        +Space(): PersonalSpace
        +Field(): PlayerField
    }

    class PersonalSpace {
        -playerHand: Arraylist<PlayableCard>
        -playerObjective: ObjectiveCard
        -sizeOfHand: int
        -maxObjectives: int

        +getPlayerHand(): Arraylist<PlayableCard>
        +getPlayerObjective(): ObjectiveCard

        '+clearAll(): void'
        +clearAll(Map<DeckType,Deck>): void
        +addCardToHand(PlayableCard): void
        +addObjectiveToHand(ObjectiveCard): void
        +pickCard(int): PlayableCard
    }

    class PlayerField{
        -cardsPositioned: Hashmap<Position, CardContainer>
        -exposedSymbols: EnumMap<Symbol, Integer>
        -exposedColors: EnumMap<Color, Integer>
        -placedCardColors: EnumMap<Color, Integer>
        -availablePositions: Set<Position>

        +place(PlayableCard): void
        '+clearAll(): void'
        +clearAll(Map<DeckType, Deck): void
        +getPositionedCards(): Map<Position, CardContainer>
        +getNumberOfPositionedCardsOf(Color): int
        +getAvailablePositions(): Set<Position>
        +countObjectivesPoints(ArrayList<ObjectiveCard>): int
    }

    Player "1" -- "1" PersonalSpace
    PlayerField "1" -- "1" Player

    class CardContainer{
        -coveredCorners: EnumMap<Corner, boolean>
        -card: PlayableCard

        +cover(Corner): void
        +getCard(): PlayableCard
    }

    class Position{
        -x: int
        -y: int

        +Position(x, y)
    }

    Position -- PlayerField
    CardContainer -- PlayerField
}

package table{
    class PickablesTable{
        -commonObjectives : Arraylist<ObjectiveCard>
        -shownCards: Arraylist<PlayableCard>
        -NumOfObjectives : int
        -NumOfShownPerType : int
        -decks : EnumMap<DeckType, Deck>

        +getShownCards(): Arraylist<PlayableCard>
        +getCommonObjectives(): Arraylist<ObjectiveCard>
        +getResouceDeckTop(): Color
        +getGoldDeckTop(): Color

        +loadPickableTable(): void
        +loadCommonOnjective(): void

        +pickCardFromTable(int): PlayableCard
        +pickFromDeck(DeckType): PlayableCard
        +clearTable(): void
        +resetDeck(DeckType): void

         
    }

    class Plateau{
        -playerPoints: Map<Player, Integer>
        -armageddonTime : int
        -numOfPlayers : int
        -isArmageddonTime : boolean

        +reset(): void
        +addPlayer(Player): void
        +addPlayerPoints(Player, int): void
        +getPlayerPoints(Player): int
        +getLeadingPlayer(): List<Player>
    }
}

interface GameModel{

    'il controller identifica i players con il loro nome'
    +initGame(): void
    +addPlayerToTable(String, PlayerColor): void
    +shufflePlayers(): void
    +setStartingPlayer(): void
    +goNextTurn(): void
    +placeCard(int): void
    +drawCardFrom(PlayableDeckType): PlayableCard

    +getExposedCards(): ArrayList<PlayableCard>
    +getPlayerHand(String): ArrayList<PlayableCard>
    +getPlayerObjective(String): ObjectiveCard
    +getCommonObjectives(): ArrayList<ObjectiveCard>
    +getPlateau(): Map<String, Integer>
    +getPlayerColor(String): PlayerColor
    +getPlayers(): ArrayList<String>
    +getCurrentTurnPlayer(): String
    +isFinished(): boolean
    +getResults(): Map<String, Integer>
    +getWinner(): String
    -getPlayer(String): Player
}

class GameLogic implements GameModel{
    -playerQueue: LinkedList<Player>
    -numOfPlayers: int
    -gameTable: Table
    -gamePlateau: Plateau
    -firstPlayer: Player
    -decks: EnumMap<DeckType, Deck>
}


package ruleset{
    interface RuleSet{
        +MaxHandSize(): int
        '+MaxShownCardsOf(PlayableCardType): int'
        +MaxShownCardsPerType(): int
        +MaxPlayerObjectives(): int
        +MaxTableObjectives(): int
        +MaxPlayers(): int
        +ToArmageddon(): int
    }

    class BasicRuleset implements RuleSet{
        -maxHandCards: int
        '-maxShownCards: EnumMap<PlayableCardType, Integer>'
        -maxShownCardsPerType: int
        -maxPersonalObjectives: int
        -maxCommonObjectives: int
        -maxPlayers: int
        -pointsToArmageddon: int
    }
}
RuleSet -- GameLogic

GameLogic -- decks
GameLogic -- cards
GameLogic -- Plateau
GameLogic -- PickablesTable
GameLogic -- Player


@enduml